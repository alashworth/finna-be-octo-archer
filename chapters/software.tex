\chapter{Firmware Design}

Software has a critical impact on hardware design. Typically, for a project like this, either ContikiOS\cite{dunkels2011contiki} or TinyOS\cite{levis2005tinyos} would be chosen. Both of them are componentized operating systems that are the de-facto standard in wireless embedded systems research. However, neither was used for this project. Instead, the board runs a port of the QP Framework\cite{samek2008practical}, an event-based actor framework combined with a very simple, cooperative multitasking kernel. The advantage of choosing a bare-metal solution is that the kernel can be swapped out in the future depending on application requirements. If necessary, a pre-emptive kernel could be used in order to provide hard real-time guarantees to executing software. No such capability is supported by TinyOS or ContikiOS, because of the resource constraints imposed by the platforms they must support.

As a result of running directly on the microcontroller, there is very little hardware abstraction; peripherals and MCU features must be directly programmed and accessed via the ROM functions provided by the manufacture. New events are easily created and assigned to the QP scheduler, which schedules all tasks in a run-to-completion fashion. For this design, given that the hard real-time demands of the networking subsystem are serviced in a separate, dedicated microcontroller in the CC3200 package, a cooperative, non-preemptive kernel was judged to be appropriate. It is simple to implement, uses less stack and memory space, and does not suffer from the complexity of traditional preemptive real-time operating systems.
 
\section{Radio Duty Cycling, Data Aggregation, and Low Power Modes}

The node design is based on the following low duty cycle principle: the node is asleep for the majority of the time, wakes up quickly on an event, processes, and returns to sleep. For the lowest power consumption, the standby current and wakeup time (time to transition from sleep to active mode) must be minimized\cite{puccinelli2005wireless} since the the active portion of a sensor network application is typically extremely small\cite{shnayder2004simulating}. 

!!!Integration of programming, communication, storage, and sensing allows researchers to utilize more functionality and develop more robust systems.

\todo{reword above paragraph}

Wireless transmission and receive are the dominant power consumers in most battery-powered devices. The board designed here is no exception, with energy consumption dominated by the transceiver. A representative pie chart has been calculated assuming the transmission of one 8-bit sample per second, and is shown below.

\missingfigure{Relative power consumption of different subsystems}

From the pie chart, it is clear that the energy consumption bottleneck lies in the wireless radio. Several techniques can be used here to reduce power consumption: compressing the data stream, and employing burst transmissions.

\subsection{Burst Transmission}

A wireless sensor node spends most of time engaged in one-way communication. Very rarely does it need to be actively listening for commands from another device. If the node collects data at a fixed rate, then the radio on time can be minimized by buffering as much data as possible, and then transmitting it. At all other times, the radio can be placed in a power-saving idle or sleep mode. This trades power consumption for data latency and device memory.

Let the average power drawn by the radio during bursts be defined as $P_{B}$. Then, 

\begin{equation}
P_{B} = \frac{1}{T_{B}}[E_{oh} + T_{TX} +(T_{B}-T_{TX})P_{idle}]\cite{calhoun2005design}
\end{equation}

where $T_{B}$ is the period between bursts, $E_{oh}$ is the radio on/off power toggling cost, $T_{TX}$ is the transmission time, $P_{TX}$ is the power consumed during transmission, and $P_{idle}$ is the power consumed while the radio is asleep.



 
\section{Server Data Storage}
\section{Rest API Interface}
\section{Data Compression}
\subsection{Goulomb Coding}

